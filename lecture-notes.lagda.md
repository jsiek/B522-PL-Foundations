```
module lecture-notes where
```

Naturals
--------

Concepts: datatype definitions, constructors, `Set`.

```
data Nat : Set where
  zero : Nat
  suc : Nat → Nat
```

Here are some natural numbers:

```
one = suc zero
two = suc (suc zero)
```

The main way to eliminate a datatype in Agda is to define a recursive
function on it.

```
add : Nat → Nat → Nat
add zero n = n
add (suc m) n = suc (add m n)
```

```
three = add two one
```

To talk about equality we import Agda's `≡` operator.

```
open import Relation.Binary.PropositionalEquality using (_≡_; refl)
```

To prove that something is equal to itself, use `refl`.

```
two-plus-one-is-three : add two one ≡ suc (suc (suc zero))
two-plus-one-is-three = refl
```

Proofs about all the naturals numbers
-------------------------------------

To prove something about all the natural numbers,
such as 

    x + y + x ≡ 2 * x + y

for all x and y, your plan A should be to try and prove
it using the laws of algebra, which are provided in the Agda
standard library.

```
open import Data.Nat
open import Data.Nat.Properties
open Relation.Binary.PropositionalEquality.≡-Reasoning using (begin_; _≡⟨_⟩_; _∎)
open import Relation.Binary.PropositionalEquality using (sym; cong; cong₂)
```

See the Agda standard library module `Algebra.Definitions` for the
definitions of thinks like `RightIdentity`.


```
xyx : (x : ℕ) → (y : ℕ) → x + y + x ≡ 2 * x + y
xyx x y =
  let L = +-identityˡ in
  let R = +-identityʳ in
  begin
    (x + y) + x
  ≡⟨ +-assoc x y x ⟩
    x + (y + x)
  ≡⟨ cong₂ _+_ {x = x} refl (+-comm y x) ⟩
    x + (x + y)
  ≡⟨ sym (+-assoc x x y) ⟩
    (x + x) + y
  ≡⟨ cong₂ _+_ {u = y} (cong₂ _+_ refl (sym (+-identityʳ x))) refl ⟩
    (x + (x + zero)) + y
  ≡⟨ refl ⟩
    2 * x + y
  ∎
```


Induction
---------

If you don't see a way to prove something about all the natural
numbers using the laws of algebra, then your plan B should be to use
induction.

Such situations often arise when you need to prove something about a
function that you have defined. For example, consider the following
silly example of a recursive function that doubles its input.

```
dub : ℕ → ℕ
dub 0 = 0
dub (suc n) = suc (suc (dub n))
```

We prove that `dub` is correct by induction. That is, we write a
recursive function that takes an integer and returns a proof that

    dub n ≡ n + n

The easiest part of a proof-by-induction is the base case, that is,
for zero. If you have trouble with the base case, there's a good
chance that what you're trying to prove is actually false.

The high-point of a proof-by-induction is the use of the induction
hypothesis (IH), that is, when we make a recursive call. Sometimes we
need to do some reasoning before using the induction hypothesis and
sometimes we do some reasoning afterwards.

```
dub-correct : (n : ℕ) → dub n ≡ n + n
dub-correct zero = refl
dub-correct (suc n) =
  let IH = dub-correct n in
  begin
    suc (suc (dub n))
  ≡⟨ cong suc (cong suc IH) ⟩
    suc (suc (n + n))
  ≡⟨ cong suc (sym (+-suc n n)) ⟩
    suc (n + suc n)
  ∎
```

Predicates, Inductively Defined
-------------------------------

```
data Even : ℕ → Set where
  E-z : Even 0
  E-ss : (n : ℕ) → Even n → Even (n + 2)
```

```
Even-2 : Even 2
Even-2 = E-ss 0 E-z

Even-4 : Even 4
Even-4 = E-ss 2 Even-2
```

If we know a number is Even, then it must have been generated by one
of the two rules.

```
inv-Even : (n m : ℕ) → Even m → n + 2 ≡ m → Even n
inv-Even n .0 E-z n+2≡m
    with m+n≡0⇒n≡0 n n+2≡m
... | ()   
inv-Even n .(n₁ + 2) (E-ss n₁ even-m) m≡n+2
    rewrite +-cancelʳ-≡ n n₁ m≡n+2 = even-m
```

```
open import Data.Nat.Solver using (module +-*-Solver)
open +-*-Solver

snsn≡nn2 : (n : ℕ) → ((1 + n) + (1 + n)) ≡ (n + n) + 2
snsn≡nn2 = solve 1 (λ n → ((con 1 :+ n) :+ (con 1 :+ n)) := (n :+ n) :+ con 2) refl
```

```
even-dub : (n : ℕ) → Even (n + n)
even-dub zero = E-z
even-dub (suc n) rewrite snsn≡nn2 n =
    E-ss (n + n) (even-dub n)
```


Relations, Inductively Defined
------------------------------

```
open import Relation.Binary.PropositionalEquality using (_≢_)
open import Data.Empty
open import Data.Product renaming (_,_ to ⟨_,_⟩)
```

```
data _divides_ : ℕ → ℕ → Set where
  div-refl : (n : ℕ) → n ≢ 0 → n divides n
  div-step : (n m : ℕ) → m divides n → m divides (m + n)
```

```
divides-+ : (m n p : ℕ) → m divides n → m divides p → m divides (n + p)
divides-+ m .m .m (div-refl .m x) (div-refl .m x₁) = div-step m m (div-refl m x)
divides-+ m .m .(m + n) (div-refl .m x) (div-step n .m mp) = div-step (m + n) m (div-step n m mp)
divides-+ m .(m + n) p (div-step n .m mn) mp rewrite +-assoc m n p =
  let IH = divides-+ m n p mn mp in 
  div-step (n + p) m IH
```

```
divides-nz : (m n : ℕ) → m divides n → m ≢ 0
divides-nz m .m (div-refl .m x) = x
divides-nz m .(m + n) (div-step n .m mn) = divides-nz m n mn
```

```
divides→alt : (m n : ℕ) → m divides n → Σ[ k ∈ ℕ ] k * m ≡ n
divides→alt m .m (div-refl .m x) = ⟨ 1 , +-identityʳ m ⟩
divides→alt m .(m + n) (div-step n .m mn)
   with divides→alt m n mn
... | ⟨ k , eq ⟩ rewrite sym eq = ⟨ (suc k) , refl ⟩
```

```
m-div-km : (k m : ℕ) → m ≢ 0 → m divides (suc k * m)
m-div-km zero m m≢0 rewrite +-identityʳ m = div-refl m m≢0
m-div-km (suc k) m m≢0 =
  let IH = m-div-km k m m≢0 in
  div-step (m + k * m) m IH
```

```
divides-trans : (m n p : ℕ) → m divides n → n divides p → m divides p
divides-trans m n p mn np
    with divides→alt m n mn | divides→alt n p np
... | ⟨ k₁ , eq₁ ⟩ | ⟨ k₂ , eq₂ ⟩ rewrite sym eq₁ | sym eq₂ | sym (*-assoc k₂ k₁ m) =
  let x = m-div-km (k₂ * k₁) m m-nz in
  {!!}
  where
     km-nz = divides-nz (k₁ * m) ((k₂ * k₁) * m) np 
     m-nz : m ≢ 0
     m-nz refl = km-nz (*-zeroʳ k₁) 
```
